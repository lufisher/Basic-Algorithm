一、冒泡排序
冒泡排序算法的运作如下：（从后往前）
1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3、针对所有的元素重复以上的步骤，除了最后一个。
4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

算法分析：
1、若文件的初始状态是正序的，一趟扫描即可完成排序，也就是最好时间复杂度O(n)
2、若初始文件是反序的，也就是最坏时间复杂度O(n^2)
3、平均时间复杂度O(n^2)

稳定性：
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生
在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个
相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素
的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

代码：
void bubble_sort(T arr[], int len)
{
    int i, j;  T temp;
    for (i = 0; i < len - 1; i++)//遍历，交换
        for (j = 0; j < len - 1 - i; j++)
        if (arr[j] > arr[j + 1])
        {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
}

二、选择排序
算法思想：
选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序
的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素
排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，
导致第一个5挪动到第二个5后面）

算法分析：
最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换
所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

稳定性：
选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元
素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了
。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面
，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5
会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

代码：
void sort(int list[], int n)
{
    int i, j, min, temp;
    for (i = 0; i < n - 1; i++){
        min = i;
        for (j = i + 1; j < n; j++)
        if (list[j] < list[min])
            min = j;
        SWAP(list[i], list[min], temp);
    }
}

三、插入排序
思想：
有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然
有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已
经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂
度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元
素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待
插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。
插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置
上，直到全部插入完为止。

算法分析：
如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是
升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此
时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算
法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量
很小，例如，量级小于千，那么插入排序还是一个不错的选择。

稳定性：
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第
一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入
在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放
在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

代码：
void insert_sort(int*array,unsignedintn)
{
    int i,j;
    int temp;
    for(i=1;i<n;i++)
    {
        temp=*(array+i);
	for(j=i;j>0&&*(array+j-1)>temp;j--)
        {
	    *(array+j)=*(array+j-1);
	}
	*(array+j)=temp;
    }
}

void InsertionSort(int array[],int first,int last){
    int i,j;
    int temp;//暂时的存储变量
    for(i=first+1;i<last;i++){
	temp=array[i];
	j=i-1;
  	while((j>=0)&&(array[j]>temp)){//移动数据的同时，找到要插入的位置
	    array[j+1]=array[j];
            j--;
	}
	if(j!=i-1)//进行插入。若j=i-1，自然也不需要插入了
	    array[j+1]=temp;
    }
}
